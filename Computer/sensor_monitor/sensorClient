-- listen for requests from the monitor
-- and reply with sensor data

-- check for debug mode
local isDebug = false
local arg = { ... }
if arg[1] == 'debug' then
  isDebug = true
  debugFile = io.open("sensorDebug.txt", "w")
end

local snsr, modem, targets
local MODEM_CHANNEL = 3

--os.loadAPI("serialize")

-- check sides for modem and sensor and initialize them
function initPeripherals()
  for k, v in pairs(rs.getSides()) do
    local pType = peripheral.getType(v)
    if pType == "modem" then
      modem = peripheral.wrap(v)
      modem.open(MODEM_CHANNEL)
      print("Loaded Modem from " .. v)
    elseif pType == "sensor" then
      os.loadAPI("ocs/apis/sensor")
      snsr = sensor.wrap(v)
      print("Loaded Sensor from " .. v)
    end
  end
end

-- get the cofig for the targets to watch
function initTargets()
  -- check config file exists
  local filename = "sensorConfig"
  local configExists = false
  local file = io.open(filename,"r")
  if file ~= nil then
    configExists = true
    file:close()
    targets = dofile(filename)
    dumpTable(targets)
  end
end


function getSensorData()
  local ret = {}
  
  -- ensure a sensor is present
  if snsr then
    ret['sensor'] = snsr.getSensorName()
  else
    ret['error'] = 'no sensor'
    return ret
  end

  -- look for sensor targets
  local snsrTargs = snsr.getTargets()
  if targets then
    -- loop through targets on the sensor
    for position, details in pairs(snsrTargs) do
      -- only use targets with names
      if details["Name"] ~= "" then
        -- if we've specified a list of targets
        if #targets then
          -- only add targets in list
          for i, v in ipairs(targets) do
            if v == details["Name"] then
              -- add sensor data
              ret['data'][details["Name"]] = snsr.getTargetDetails(position)
              break
            end
          end
        else
          -- add any sensor data
          ret['data'][details["Name"]] = snsr.getTargetDetails(position)
        end
      end
    end
  else
    ret['error'] = 'no targets'
    return ret
  end
  if not ret['data'] then
    ret['error'] = 'no data'
  end
  return ret
end

-- recursively print key/value from a table
-- write to the debug file if in debug mode
function dumpTable(table, depth)
  isDebug = true
  if type(table) ~= "table" then 
    print(table)
  end
  if not depth then depth = 0 end
  for k, v in pairs(table) do
    print(k)
    if type(v) ~= 'table' then
      if v ~= "" then
        v = tostring(v)
        for i = 0, depth, 1 do
          io.write(" ")
          if isDebug then
            debugFile:write(" ")
          end
        end
        print(k .. ": " .. v)
        if isDebug then
          debugFile:write(k .. ": " .. v .. "\n")
        end
      end
    else
      print(k .. ": ")
      if isDebug then
        debugFile:write(k .. ": \n")
      end
      dumpTable(v, depth + 1)
    end
  end
end

-- send data through the modem
-- return true if data nd no errors
function sendData(data)
  if data['data'] then
    local serialData = serialize.serialize(data)
    modem.transmit(p3, 0, serialData)
    if isDebug then
      dumpTable(data)
      print(data)
    end
    return true
  elseif data['error'] then
    print(data['error'])
    return false
  else
    print('failed no error')
    return false
  end
end
-- end functions

initPeripherals()
initTargets()

local data = false
if not isDebug then
  print("listening for monitor on channel " .. MODEM_CHANNEL .. "...")
  for event, p1, p2, p3, p4, p5 in os.pullEvent do
    if event == "modem_message"
      and p4 == "getSensorData"
    then
      data = getSensorData()
    elseif event == "char" and p1 == "x" then
      break
    end 
  end
else
  -- debugging - get data and quit
  print("Debugging sensor data...")
  sendData(getSensorData())
  debugFile:close()
end


